3.	正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。对于复杂的字符串匹配任务，编写大量的循环嵌套代码费时费力，因此通过历史的沉淀积累和长时间的探索，出现了正则表达式。应用的基本思路是使用一个按规定编写的特殊符号表达式来代表所要匹配的字符串的格式要求，然后使用正则表达式库来解析同时比较待匹配字符串。C++11引入了正则表达式标准库<regex>，在此之后我们可以使用std命名空间下的<regex>库函数和对象来完成正则匹配的任务。
	下面介绍本体涉及的正则表达式内容：所有大小写字母在正则表达式中都代表本身，即你可以在正则表达式字符串中写入"ab"来表示需要匹配第一个字母为a，第二个字母为b的字符串，比如"abcdd"。加号"+"表示重复匹配前面的那个字符（或用小括号扩起的字符串单元）1次或多次。当我们使用加号"+"匹配失败时会产生回溯状态（附图）。大括号组{n，m}括起来的部分表示前面的那个字符（或用小括号扩起的字符串单元）重复n至m次（可以是任何一种情况，n<m）。
	回溯在某些情况下会出现回溯失控的情况，比如下面这个例程，通过记录程序运行时间可以发现，表达式因为无法匹配到最后一个字符s，而在“两个"a+"分别匹配某一数量a”的状况内不断的回溯，如果增加待匹配字符串的前面重复字符a的数量，匹配的时间将会进一步增长。
//******************************************************************
#include<iostream>  
#include<regex>
#include<windows.h>
#include<stdlib.h>

int main()
{
	DWORD start_time = GetTickCount();//获取系统时间，单位毫秒，DWORD双字，当int处理
	std::regex r("(a+a+)+s"); //声明r为正则表达式并赋值为"(a+a+)+s"，当字符串处理
	std::string s="aaaaaaaaaaaa"; //待匹配字符串，这里有12个a
	if (std::regex_match(s, r))//匹配正则表达式
		std::cout << "get it!" << std::endl;
	DWORD end_time = GetTickCount();
	std::cout << "The run time is:" << (end_time - start_time) << "ms!" << std::endl;
	system("pause");
	return 0;
}
//******************************************************************
	当a的数量为10时，程序输出的运行时间为156ms，当a的数量为12时，程序输出的运行时间为532ms，试问a的数量为14时，程序显示的运行时间会是多少？（注，实测时间在a的数量较大时（比如a==12）会产生波动，每次得到的结果不同，本题要求使用题目数据，假定计算机的计算能力保持不变，同时所有非匹配部分代码所耗费时间相同，自己建立计算模型进行预测）

答案：2036（1900-2100都可以，且用下面思路做出的答案与实际值相差不大）
思路：假设使用循环对字符注意逐一匹配，每个字符匹配的时间长度相同，计算出回溯导致的两种情况需要匹配字符的次数，然后列二元一次方程组解出公共部分耗时和匹配部分耗时，最后用解方程得到的结果计算a的数量为14时的状况即可。
512x+y=156
2048x+y=532
x=376/1536=0.244791666666
y=30.66666666
time=2^13x+y=2035.99999=2036